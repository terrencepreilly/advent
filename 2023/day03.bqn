data â† > â€¢FLines "/dev/stdin"

IsDigit â† '9'âŠ¸â‰¥ âˆ§ '0'âŠ¸â‰¤
IsSpace â† '.'âŠ¸=
IsSymbol â† Â¬ IsDigit âˆ¨ IsSpace
SymbolIndex â† âˆ˜â€¿2âŠ¸â¥Š âˆ˜ âˆ¾ âˆ˜ â¥Š IsSymbol /Â¨ â†•âˆ˜â‰¢

# Given a offset, returns a function which takes
# a map (ğ•¨) and an index (ğ•©) and returns 0 if it's not a number.
_IsNumberAt â† { offset _op:
  InRangeL â† 0â€¿0 â‰¤ offset + âŠ¢
  InRangeU â† â‰¢âˆ˜âŠ£ > offset + âŠ¢
  InRange â† âˆ§Â´ InRangeL âˆ§ InRangeU
  CheckDigit â† IsDigit (offset + âŠ¢) âŠ‘ âŠ£
  InRangeâ—¶âŸ¨âŸ©â€¿(CheckDigitâ—¶âŸ¨âŸ©â€¿(offset + âŠ¢))
}

# While the number to the left of this is a digit, subtract one.
LeftRaw â† (0â€¿Â¯1 + âŠ¢)
Left â† (âˆ§Â´ 0â€¿0 â‰¤ LeftRaw)â—¶âŠ¢â€¿LeftRaw
StepCanonical â† (IsDigit âŠ‘ËœâŸœLeft)â—¶âŠ¢â€¿Left # (IsDigitâˆ˜âŠ‘Ëœ)
GetCanonical â† StepCanonicalâŸ100 # TODO: Replace with recursion
GetNumbers â† âˆ˜â€¿2 â¥Š (0â€¿1 _IsNumberAt) âˆ¾ (0â€¿Â¯1 _IsNumberAt) âˆ¾ (1â€¿0 _IsNumberAt) âˆ¾ (Â¯1â€¿0 _IsNumberAt) âˆ¾ (1â€¿1 _IsNumberAt) âˆ¾ (1â€¿Â¯1 _IsNumberAt) âˆ¾ (Â¯1â€¿1 _IsNumberAt) âˆ¾ (Â¯1â€¿Â¯1 _IsNumberAt)

# There must be a better way to do this?
GetStarting â† { â· (ğ•©âŠ¸GetCanonical)Â¨ <Ë˜ âˆ¾ (ğ•©âŠ¸GetNumbers)Â¨ <Ë˜ SymbolIndex ğ•© }

GetLine â† (âŠËœâŸœ(âŠ‘âˆ˜âŠ¢))
TakeDigitPrefix â† â€¢ParseFloat âˆ˜ âŠ‘ âˆ˜ ((+` Â¬âˆ˜IsDigit)âŠ¸âŠ”)
GetDigit â† TakeDigitPrefix (1âŠ¸âŠ‘âˆ˜âŠ¢ â†“ GetLine)

Solution â† { +Â´ ğ•©âŠ¸GetDigitÂ¨ GetStarting ğ•© }



GetSymbolIndices â† <Ë˜âˆ˜SymbolIndex
IsAsterix â† '*' = GetSymbolIndicesâŠ¸âŠ‘
GetAsterixIndices â† IsAsterix / GetSymbolIndices
FilterOverTwo â† (2 â‰¤ â‰ Â¨ ) / âŠ¢

GetGearNumbers â† { ğ•¤ â‹„
  indices â† GetAsterixIndices ğ•©
  numbers â† (ğ•©âŠ¸GetNumbers)Â¨ indices
  numbers â†© (â· (ğ•©âŠ¸GetCanonical)Â¨ âˆ˜ <Ë˜)Â¨ numbers

  gearNumberIndices â† ((2 = â‰ )Â¨ numbers) / numbers
  ğ•©âŠ¸GetDigitÂ¨Â¨ gearNumberIndices
}

Solution2 â† +Â´ Ã—Â´Â¨ âˆ˜ GetGearNumbers

â€¢Out â€¢Repr Solution2 data

# â€¢Out â€¢Repr Solution data
