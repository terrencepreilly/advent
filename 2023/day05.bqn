data â† â€¢FLines "/dev/stdin"

# Remove spaces
StripLeft â† (+Â´ âˆ˜ (0âŠ¸=) âˆ˜ (+`) âˆ˜ Â¬ âˆ˜ (' 'âŠ¸=))âŠ¸â†“
Strip â† StripLeft StripLeftâŒ¾âŒ½

# Remove double 1s from a mask. This ensures we won't have extra spaces.
# (Which would lead to empty lists when we group.)
DoubleMask â† âˆ§âŸœ((Â¬âˆ˜âˆ§Â´Ë˜)âˆ˜(2âŠ¸â†•) âˆ¾ Â¯1 âŠ‘ âŠ¢)
GetNumbers â† â€¢ParseFloatÂ¨ (Â¬âˆ˜(' 'âŠ¸=) / +`âˆ˜DoubleMaskâˆ˜(' 'âŠ¸=)) âŠ” Â¬âˆ˜(' 'âŠ¸=)âŠ¸/

IndexOf â† âŠ‘ (âŠ¢ / â†•âˆ˜â‰ )âˆ˜â·Ëœ
SplitBy â† (IndexOf â†‘ âŠ£) â‹ˆ ((â‰ âˆ˜âŠ¢ + IndexOf) â†“ âŠ£)
TakeTo â† IndexOf â†‘ âŠ£

ParseSeeds â† (GetNumbersâˆ˜Stripâˆ˜(6âŠ¸â†“))âˆ˜âŠ‘

DiscardToEmpty â† {
  âŸ¨âŸ© â‰¡ ğ•© ? âŸ¨âŸ© ;
  (âŸ¨âŸ©â‰¡âŠ‘)â—¶(ğ•Š âˆ˜ (1âŠ¸â†“))â€¿(âŠ¢) ğ•©
}
ParseMapName â† Stripâˆ˜(TakeToâŸœ"map:")âŒ¾(1âŠ¸âŠ‘) (SplitByâŸœ"-to-")
ParseMapNumbers â† {
  âŸ¨âŸ© â‰¡ ğ•© ? âŸ¨âŸ© ;
  (âŸ¨âŸ©â‰¡âŠ‘)â—¶(â‹ˆâˆ˜GetNumbersâˆ˜âŠ‘ âˆ¾ ğ•¤âˆ˜(1âŠ¸â†“))â€¿(âŸ¨âŸ©) ğ•©
}
ParseMap â† DiscardToEmpty â‹ˆËœ ParseMapNameâˆ˜âŠ‘ â‹ˆ >âˆ˜ParseMapNumbersâˆ˜(1âŠ¸â†“)

ParseMaps â† âˆ˜â€¿2âŠ¸â¥Š âˆ˜ {
  âŸ¨âŸ© â‰¡ ğ•© ? âŸ¨âŸ© ;
  mâ€¿rest â† ParseMap ğ•©
  m âˆ¾ ((0 < â‰ )â—¶(âŸ¨âŸ©)â€¿(ğ•Š 1âŠ¸â†“)) rest
} âˆ˜ (2âŠ¸â†“)

# Given a map of numbers, ğ•¨, and a number ğ•©, find what number ğ•© maps to.
# The map consists of lines, where each line has the format
#
#   <dest> <source> <length>.
#
# So, if source_n â‰¤ ğ•© â‰¤ (source_n + length_n), then the result will be
# dest + ğ•© - source_n.
Map â† {
  # If there are no values in the map, then the number maps to itself.
  0 = â‰  ğ•¨ ? ğ•© ;
  first â† âŠ ğ•¨
  destâ€¿sourceâ€¿length â† first
  ((sourceâŠ¸â‰¤) âˆ§  (<âŸœ(source + length)))â—¶((1 â†“ ğ•¨)âŠ¸ğ•Š)â€¿(destâŠ¸+ âˆ˜ (-âŸœsource)) ğ•©
}

# Given maps as ğ•¨, and a seed ğ•©, get the location of the seed.
# (Assumes that the maps are ordered.  That is, each map is the source
# for the following map.)
GetLocationForSeed â† {
  0 = â‰  ğ•¨ ? ğ•© ;
  curr â† 1 âŠ‘ âŠ ğ•¨
  rest â† 1 â†“ ğ•¨
  rest ğ•Š curr Map ğ•©
}

Solution â† {
  seeds â† ParseSeeds ğ•©
  maps â† ParseMaps ğ•©
  âŒŠÂ´ mapsâŠ¸GetLocationForSeedÂ¨ seeds
}

# A naive solution.
Solution2 â† {
  seeds â† ParseSeeds ğ•©
  ExtractSeeds â† âˆ¾ (< âŠ‘ + â†• âˆ˜ (1âŠ¸âŠ‘))Ë˜
  seeds â†© ExtractSeeds âˆ˜â€¿2 â¥Š seeds
  maps â† ParseMaps ğ•©
  âŒŠÂ´ mapsâŠ¸GetLocationForSeedÂ¨ seeds
}

â€¢Show Solution2 data
